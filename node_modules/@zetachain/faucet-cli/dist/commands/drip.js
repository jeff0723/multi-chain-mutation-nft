"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.drip = void 0;
const got_1 = __importDefault(require("got"));
const constants_1 = require("../constants");
const login_1 = require("./login");
const mapHardhatNetworksToFaucetNetworks = (network) => {
    switch (network) {
        case "athens":
            return "zetachain_athens";
        case "goerli":
            return "goerli";
        case "bsc-testnet":
            return "bsc_testnet";
        case "polygon-mumbai":
            return "polygon_mumbai";
        default:
            return network;
    }
};
const drip = (options, unavailable_chains = []) => __awaiter(void 0, void 0, void 0, function* () {
    if (!options.chain || !options.address || !constants_1.VALID_CHAINS.includes(mapHardhatNetworksToFaucetNetworks(options.chain))) {
        throw new Error(`Please select a valid chain and address (current options: ${options.address}, ${options.chain}). See -h for available commands.`);
    }
    const parsedNetwork = mapHardhatNetworksToFaucetNetworks(options.chain);
    if (unavailable_chains.includes(parsedNetwork)) {
        throw new Error("This chain is currently unavailable. Please try again later or try another one.");
    }
    const token = yield (0, login_1.getGithubAccessToken)();
    console.info(`Requesting assets for ${options.address} in ${parsedNetwork}.`);
    const response = yield got_1.default.post(constants_1.FAUCET_VALIDATOR_URL, {
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
            coins: [
                {
                    chain: parsedNetwork,
                    symbol: "ZETA",
                },
            ],
            address: options.address,
        }),
        throwHttpErrors: false,
    });
    if (response.statusCode > 300) {
        switch (response.statusCode) {
            case 400:
                console.error("Invalid address");
                break;
            case 401:
                console.error("Invalid access token");
                break;
            case 429:
                console.error("You are being rate limited. Please review limits and try again later.");
                break;
            case 500:
                console.error("Internal server error");
                break;
            default:
                console.error(`Unknown error ${response.statusCode}${JSON.stringify(response.body)}`);
        }
        throw new Error("There was an error, please review logs.");
    }
    else if (response.statusCode >= 200) {
        console.info("Success! Please wait a few minutes for the assets to arrive.");
    }
});
exports.drip = drip;
//# sourceMappingURL=drip.js.map