"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addZetaEthLiquidityTest = exports.parseInteractorLog = exports.getMintTokenId = void 0;
const constants_1 = require("@ethersproject/constants");
const typechain_types_1 = require("@zetachain/protocol-contracts/dist/typechain-types");
const typechain_types_2 = require("../typechain-types");
const address_helpers_1 = require("./address.helpers");
const deploy_helpers_1 = require("./deploy.helpers");
const getMintTokenId = (mintTx) => mintTx.events?.[0].args?.tokenId;
exports.getMintTokenId = getMintTokenId;
const parseInteractorLog = (logs) => {
    const iface = typechain_types_1.ZetaTokenConsumerUniV3__factory.createInterface();
    const eventNames = logs.map((log) => {
        try {
            const parsedLog = iface.parseLog(log);
            return parsedLog.name;
        }
        catch (e) {
            return "NO_ZETA_LOG";
        }
    });
    return eventNames;
};
exports.parseInteractorLog = parseInteractorLog;
const addZetaEthLiquidityTest = async (zetaTokenAddress, zetaToAdd, ETHToAdd, deployer) => {
    const uniswapRouterAddr = (0, address_helpers_1.getAddress)("uniswapV2Router02", {
        customNetworkName: "eth-mainnet",
        customZetaNetwork: "mainnet",
    });
    const uniswapRouter = typechain_types_2.UniswapV2Router02__factory.connect(uniswapRouterAddr, deployer);
    const ZetaTokenContract = typechain_types_2.ERC20__factory.connect(zetaTokenAddress, deployer);
    const tx1 = await ZetaTokenContract.approve(uniswapRouter.address, constants_1.MaxUint256);
    await tx1.wait();
    const tx2 = await uniswapRouter.addLiquidityETH(ZetaTokenContract.address, zetaToAdd, 0, 0, deployer.address, (await (0, deploy_helpers_1.getNow)()) + 360, { gasLimit: 10000000, value: ETHToAdd });
    await tx2.wait();
};
exports.addZetaEthLiquidityTest = addZetaEthLiquidityTest;
