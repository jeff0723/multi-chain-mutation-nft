"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.balancesTask = exports.walletError = void 0;
const addresses_1 = require("@zetachain/addresses");
const ZetaEth_json_1 = __importDefault(require("@zetachain/interfaces/abi/json/contracts/Zeta.eth.sol/ZetaEth.json"));
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
exports.walletError = `
‚ùå Error: Wallet address not found.

To resolve this issue, please follow these steps:

* Set your PRIVATE_KEY environment variable. You can write
  it to a .env file in the root of your project like this:

  PRIVATE_KEY=123... (without the 0x prefix)
  
  Or you can generate a new private key by running:

  npx hardhat account --save
`;
const balancesError = `
* Alternatively, you can fetch the balance of any address
  by using the --address flag:
  
  npx hardhat balances --address <wallet_address>
`;
const fetchNativeBalance = async (address, provider) => {
    const balance = await provider.getBalance(address);
    return parseFloat(ethers_1.ethers.utils.formatEther(balance)).toFixed(2);
};
const fetchZetaBalance = async (address, provider, networkName) => {
    if (networkName === "athens")
        return "";
    const zetaAddress = (0, addresses_1.getAddress)({
        address: "zetaToken",
        networkName,
        zetaNetwork: "athens",
    });
    const contract = new ethers_1.ethers.Contract(zetaAddress, ZetaEth_json_1.default, provider);
    const balance = await contract.balanceOf(address);
    return parseFloat(ethers_1.ethers.utils.formatEther(balance)).toFixed(2);
};
const main = async (args, hre) => {
    const { ethers, config } = hre;
    const fetchBalances = async (address, provider, networkName) => {
        try {
            const { config } = hre;
            const { url } = config.networks[networkName];
            const native = await fetchNativeBalance(address, provider);
            const zeta = await fetchZetaBalance(address, provider, networkName);
            return { native, networkName, zeta };
        }
        catch (error) { }
    };
    let address;
    if (args.address) {
        address = args.address;
    }
    else if (process.env.PRIVATE_KEY) {
        address = new ethers.Wallet(process.env.PRIVATE_KEY).address;
    }
    else {
        return console.error(exports.walletError + balancesError);
    }
    const balancePromises = Object.keys(hre.config.networks).map((networkName) => {
        const { url } = hre.config.networks[networkName];
        const provider = new ethers.providers.JsonRpcProvider(url);
        return fetchBalances(address, provider, networkName);
    });
    const balances = await Promise.all(balancePromises);
    const filteredBalances = balances.filter((balance) => balance != null);
    console.log(`
üìä Balances for ${address}
`);
    console.table(filteredBalances);
};
exports.balancesTask = (0, config_1.task)("balances", `Fetch native and ZETA token balances`, main).addOptionalParam("address", `Fetch balances for a specific address`);
