"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPrompt = exports.usePagination = exports.useKeypress = exports.useRef = exports.useEffect = exports.useState = exports.usePrefix = void 0;
const readline = __importStar(require("node:readline"));
const node_async_hooks_1 = require("node:async_hooks");
const type_1 = require("@inquirer/type");
const chalk_1 = __importDefault(require("chalk"));
const cli_width_1 = __importDefault(require("cli-width"));
const mute_stream_1 = __importDefault(require("mute-stream"));
const screen_manager_mjs_1 = __importDefault(require('./lib/screen-manager.js'));
const options_mjs_1 = require('./lib/options.js');
const utils_mjs_1 = require('./lib/utils.js');
var prefix_mjs_1 = require('./lib/prefix.js');
Object.defineProperty(exports, "usePrefix", { enumerable: true, get: function () { return prefix_mjs_1.usePrefix; } });
__exportStar(require('./lib/key.js'), exports);
__exportStar(require('./lib/Separator.js'), exports);
const hookStorage = new node_async_hooks_1.AsyncLocalStorage();
const context = {
    getStore() {
        const store = hookStorage.getStore();
        if (!store) {
            throw new Error('[Inquirer] Hook functions can only be called from within a prompt');
        }
        return store;
    },
    withPointer(cb) {
        const store = context.getStore();
        const value = cb(store.index, store);
        store.index++;
        return value;
    },
    handleChange() {
        const { handleChange } = context.getStore();
        handleChange();
    },
    mergeStateUpdates(fn) {
        const wrapped = (...args) => {
            const store = context.getStore();
            let shouldUpdate = false;
            const oldHandleChange = store.handleChange;
            store.handleChange = () => {
                shouldUpdate = true;
            };
            const returnValue = fn(...args);
            if (shouldUpdate) {
                oldHandleChange();
            }
            store.handleChange = oldHandleChange;
            return returnValue;
        };
        return wrapped;
    },
};
const effectScheduler = {
    queue(cb) {
        const store = context.getStore();
        const { index } = store;
        store.hooksEffect.push(() => {
            var _a, _b;
            (_b = (_a = store.hooksCleanup)[index]) === null || _b === void 0 ? void 0 : _b.call(_a);
            const cleanFn = cb(store.rl);
            if (cleanFn != null && typeof cleanFn !== 'function') {
                throw new Error('useEffect return value must be a cleanup function or nothing.');
            }
            store.hooksCleanup[index] = cleanFn;
        });
    },
    run: context.mergeStateUpdates(() => {
        const store = context.getStore();
        store.hooksEffect.forEach((effect) => {
            effect();
        });
        store.hooksEffect.length = 0;
    }),
};
function useState(defaultValue) {
    return context.withPointer((pointer, store) => {
        const { hooks } = store;
        if (!(pointer in hooks)) {
            if (typeof defaultValue === 'function') {
                hooks[pointer] = defaultValue();
            }
            else {
                hooks[pointer] = defaultValue;
            }
        }
        return [
            hooks[pointer],
            (newValue) => {
                // Noop if the value is still the same.
                if (hooks[pointer] !== newValue) {
                    hooks[pointer] = newValue;
                    // Trigger re-render
                    context.handleChange();
                }
            },
        ];
    });
}
exports.useState = useState;
function useEffect(cb, depArray) {
    return context.withPointer((pointer, store) => {
        const { hooks } = store;
        const oldDeps = hooks[pointer];
        const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
        if (hasChanged) {
            effectScheduler.queue(cb);
        }
        hooks[pointer] = depArray;
    });
}
exports.useEffect = useEffect;
function useRef(val) {
    return useState({ current: val })[0];
}
exports.useRef = useRef;
function useKeypress(userHandler) {
    const signal = useRef(userHandler);
    signal.current = userHandler;
    useEffect((rl) => {
        const handler = node_async_hooks_1.AsyncResource.bind(context.mergeStateUpdates((_input, event) => {
            signal.current(event, rl);
        }));
        rl.input.on('keypress', handler);
        return () => {
            rl.input.removeListener('keypress', handler);
        };
    }, []);
}
exports.useKeypress = useKeypress;
function usePagination(output, { active, pageSize = 7, }) {
    const { rl } = context.getStore();
    const state = useRef({
        pointer: 0,
        lastIndex: 0,
    });
    const width = (0, cli_width_1.default)({ defaultWidth: 80, output: rl.output });
    const lines = (0, utils_mjs_1.breakLines)(output, width).split('\n');
    // Make sure there's enough lines to paginate
    if (lines.length <= pageSize) {
        return output;
    }
    const middleOfList = Math.floor(pageSize / 2);
    // Move the pointer only when the user go down and limit it to the middle of the list
    const { pointer: prevPointer, lastIndex } = state.current;
    if (prevPointer < middleOfList && lastIndex < active && active - lastIndex < pageSize) {
        state.current.pointer = Math.min(middleOfList, prevPointer + active - lastIndex);
    }
    state.current.lastIndex = active;
    // Duplicate the lines so it give an infinite list look
    const infinite = [lines, lines, lines].flat();
    const topIndex = Math.max(0, active + lines.length - state.current.pointer);
    const section = infinite.splice(topIndex, pageSize).join('\n');
    return section + '\n' + chalk_1.default.dim('(Move up and down to reveal more choices)');
}
exports.usePagination = usePagination;
function createPrompt(view) {
    const prompt = (config, context) => {
        var _a, _b;
        // Default `input` to stdin
        const input = (_a = context === null || context === void 0 ? void 0 : context.input) !== null && _a !== void 0 ? _a : process.stdin;
        // Add mute capabilities to the output
        const output = new mute_stream_1.default();
        output.pipe((_b = context === null || context === void 0 ? void 0 : context.output) !== null && _b !== void 0 ? _b : process.stdout);
        const rl = readline.createInterface({
            terminal: true,
            input,
            output,
        });
        const screen = new screen_manager_mjs_1.default(rl);
        const store = {
            rl,
            hooks: [],
            hooksCleanup: [],
            hooksEffect: [],
            index: 0,
            handleChange() { },
        };
        let cancel = () => { };
        const answer = new type_1.CancelablePromise((resolve, reject) => {
            hookStorage.run(store, () => {
                const checkCursorPos = () => {
                    screen.checkCursorPos();
                };
                const onExit = node_async_hooks_1.AsyncResource.bind(() => {
                    try {
                        store.hooksCleanup.forEach((cleanFn) => {
                            cleanFn === null || cleanFn === void 0 ? void 0 : cleanFn();
                        });
                    }
                    catch (err) {
                        reject(err);
                    }
                    if (context === null || context === void 0 ? void 0 : context.clearPromptOnDone) {
                        screen.clean();
                    }
                    else {
                        screen.clearContent();
                    }
                    screen.done();
                    process.removeListener('SIGINT', onForceExit);
                    store.rl.input.removeListener('keypress', checkCursorPos);
                });
                cancel = node_async_hooks_1.AsyncResource.bind(() => {
                    onExit();
                    reject(new Error('Prompt was canceled'));
                });
                let shouldHandleExit = true;
                const onForceExit = node_async_hooks_1.AsyncResource.bind(() => {
                    if (shouldHandleExit) {
                        shouldHandleExit = false;
                        onExit();
                        reject(new Error('User force closed the prompt with CTRL+C'));
                    }
                });
                // Handle cleanup on force exit. Main reason is so we restore the cursor if a prompt hide it.
                process.on('SIGINT', onForceExit);
                const done = (value) => {
                    // Delay execution to let time to the hookCleanup functions to registers.
                    setImmediate(() => {
                        onExit();
                        // Finally we resolve our promise
                        resolve(value);
                    });
                };
                const workLoop = (resolvedConfig) => {
                    store.index = 0;
                    store.handleChange = () => workLoop(resolvedConfig);
                    try {
                        const nextView = view(resolvedConfig, done);
                        const [content, bottomContent] = typeof nextView === 'string' ? [nextView] : nextView;
                        screen.render(content, bottomContent);
                        effectScheduler.run();
                    }
                    catch (err) {
                        onExit();
                        reject(err);
                    }
                };
                // TODO: we should display a loader while we get the default options.
                (0, options_mjs_1.getPromptConfig)(config).then((resolvedConfig) => {
                    workLoop(resolvedConfig);
                    // Re-renders only happen when the state change; but the readline cursor could change position
                    // and that also requires a re-render (and a manual one because we mute the streams).
                    // We set the listener after the initial workLoop to avoid a double render if render triggered
                    // by a state change sets the cursor to the right position.
                    store.rl.input.on('keypress', checkCursorPos);
                }, reject);
            });
        });
        answer.cancel = cancel;
        return answer;
    };
    return prompt;
}
exports.createPrompt = createPrompt;
